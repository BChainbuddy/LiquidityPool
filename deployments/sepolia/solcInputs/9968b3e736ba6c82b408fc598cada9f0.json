{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"./ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/LiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nerror assetNotCorrect();\nerror notEnoughTokens();\nerror notEnoughGas();\nerror notEnoughTimePassed();\nerror initialLiquidityAlreadyProvided();\nerror addressNotCorrect();\nerror amountTooBig();\nerror needToCallExistingFunction();\n\n/**\n * @title LiquidityPool\n * @dev A decentralized liquidity pool contract for swapping assets and providing liquidity.\n */\ncontract LiquidityPool {\n    // Events\n    event priceChanged(address _asset, uint256 price);\n    event liquidityAdded(\n        address indexed _address,\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    );\n    event liquidityRemoved(\n        address indexed _address,\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    );\n    event yieldFarmed(address indexed _address, uint256 _amount);\n\n    // Token Addresses\n    address public assetOneAddress;\n    address public assetTwoAddress;\n\n    // Liquidity and Yield (fees)\n    uint256 public initialLiquidity;\n    uint256 public liquidity;\n    uint256 public yield;\n    uint256 public swapFee;\n    address public owner;\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /**\n     * @dev Modifier to restrict functions only to the owner.\n     */\n    modifier onlyOwner() {\n        msg.sender == owner;\n        _;\n    }\n\n    /**\n     * @dev Constructor to initialize the liquidity pool with two asset addresses.\n     * @param _assetOneAddress The address of the first asset.\n     * @param _assetTwoAddress The address of the second asset.\n     */\n    constructor(address _assetOneAddress, address _assetTwoAddress) {\n        assetOneAddress = _assetOneAddress;\n        assetTwoAddress = _assetTwoAddress;\n        owner = msg.sender;\n        swapFee = 1000000000000000; // 0.001 ether\n    }\n\n    /**\n     * @dev Function to change the swap fee. Only callable by the owner.\n     * @param newSwapFee The new swap fee to set.\n     */\n    function changeSwapFee(uint256 newSwapFee) public onlyOwner {\n        swapFee = newSwapFee;\n    }\n\n    // TRACK THE LP TOKEN QUANTITY, INITIAL LIQUIDITY\n    mapping(address => uint256) public lpTokenQuantity;\n\n    /**\n     * @dev Function to add initial liquidity to the pool. Only callable by the owner.\n     * @dev Needs the ERC-20 approval for transferFrom.\n     * @param _assetOneAmount The amount of the first asset to add.\n     * @param _assetTwoAmount The amount of the second asset to add.\n     */\n    function addInitialLiquidity(\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    ) public onlyOwner {\n        if (initialLiquidityProvidedTime[owner] > 0) {\n            revert initialLiquidityAlreadyProvided();\n        }\n        initialLiquidityProvidedTime[msg.sender] = block.timestamp;\n\n        // SENDS THE TOKENS TO THE LIQUIDITY POOL\n        IERC20(assetOneAddress).transferFrom(msg.sender, address(this), _assetOneAmount);\n        IERC20(assetTwoAddress).transferFrom(msg.sender, address(this), _assetTwoAmount);\n\n        // SET THE INITIAL LIQUIDITY\n        initialLiquidity = _assetOneAmount * _assetTwoAmount;\n        liquidity = initialLiquidity;\n\n        // GIVE LP TOKENS TO THE INITIAL LIQUIDITY PROVIDER\n        lpTokenQuantity[msg.sender] = initialLiquidity;\n\n        // EMIT EVENT\n        emit liquidityAdded(msg.sender, _assetOneAmount, _assetTwoAmount);\n    }\n\n    /**\n     * @dev Function to add additional liquidity to the pool.\n     * @dev Needs the ERC-20 approval for transferFrom.\n     * @param _asset The address of the first asset.\n     * @param _secondAsset The address of the second asset.\n     * @param _amount The amount of the first asset to add.\n     */\n    function addLiquidity(\n        address _asset,\n        address _secondAsset,\n        uint256 _amount\n    ) public noReentrancy {\n        // SET THE RATIO, require token balance provided in ERC20, reverted if too low\n        IERC20(_secondAsset).transferFrom(\n            msg.sender,\n            address(this),\n            amountOfOppositeTokenNeeded(_asset, _amount)\n        );\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n        // give lp tokens to new liquidity provider\n        lpTokenQuantity[msg.sender] += (_amount * amountOfOppositeTokenNeeded(_asset, _amount));\n        liquidity += (_amount * amountOfOppositeTokenNeeded(_asset, _amount));\n\n        // EMIT EVENT\n        emit liquidityAdded(msg.sender, amountOfOppositeTokenNeeded(_asset, _amount), _amount);\n    }\n\n    /**\n     * @dev Function to remove liquidity from the pool.\n     * @param _amount The percentage of liquidity to withdraw(10 -> 10%).\n     */\n    function removeLiquidity(uint256 _amount) public noReentrancy {\n        uint256 userLpTokens = lpTokenQuantity[msg.sender];\n        uint256 percentageOfLiquidity = (userLpTokens * 1 ether) / liquidity; // How much user owns out of all Liquidity in percentage\n        uint256 percentageOfUserLiquidity = (percentageOfLiquidity * _amount) / 100; // How much out of their liquidity they want to withdraw in percentage\n        uint256 resultAssetOne = (percentageOfUserLiquidity * getAssetOne()) / 1 ether;\n        uint256 resultAssetTwo = (percentageOfUserLiquidity * getAssetTwo()) / 1 ether;\n        // condition for owner, because of the initial liquidity timer\n        if (\n            (msg.sender == owner) &&\n            (isTimeInitialLiquidity() == false) &&\n            //the owner has the ability to withdraw liquidity if it wasn't part of initial liquidity\n            ((lpTokenQuantity[msg.sender] - (resultAssetOne * resultAssetTwo)) < initialLiquidity)\n        ) {\n            revert notEnoughTokens();\n        }\n        // check balance if it is high enough to continue, can't get reverted at transfer, it should have the balance but just in case\n        if (\n            IERC20(assetOneAddress).balanceOf(address(this)) < resultAssetOne ||\n            IERC20(assetTwoAddress).balanceOf(address(this)) < resultAssetTwo\n        ) {\n            revert notEnoughTokens();\n        }\n        IERC20(assetOneAddress).transfer(msg.sender, resultAssetOne);\n        IERC20(assetTwoAddress).transfer(msg.sender, resultAssetTwo);\n\n        // EMIT EVENT\n        emit liquidityRemoved(msg.sender, resultAssetOne, resultAssetTwo);\n    }\n\n    /**\n     * @dev Function to sell the first asset and receive the second asset.\n     * @param _amount The amount of the first asset to sell.\n     */\n    function sellAssetOne(uint256 _amount) public payable noReentrancy {\n        //PAY THE ETH FEE\n        if (msg.value < swapFee) {\n            revert notEnoughGas();\n        }\n        yield += swapFee;\n        uint256 unrequiredFee = msg.value - swapFee; // In case the msg.sender sent more value than it is required\n        //CALCULATION\n        uint256 n = getAssetTwo();\n        uint256 assetOne = getAssetOne() + _amount;\n        uint256 assetTwo = liquidity / assetOne;\n        uint256 result = n - assetTwo;\n        //SENDING THE OPPOSITE ASSET TO THE CALLER FROM LIQUIDITY POOL\n        IERC20(assetOneAddress).transferFrom(msg.sender, address(this), _amount);\n        IERC20(assetTwoAddress).transfer(msg.sender, result);\n        payable(msg.sender).transfer(unrequiredFee); // Sending back the unrequired fee\n        //EVENTS\n        emit priceChanged(assetOneAddress, assetOnePrice());\n        emit priceChanged(assetTwoAddress, assetTwoPrice());\n    }\n\n    /**\n     * @dev Function to sell the second asset and receive the first asset.\n     * @param _amount The amount of the second asset to sell.\n     */\n    function sellAssetTwo(uint256 _amount) public payable noReentrancy {\n        //PAY THE ETH FEE\n        if (msg.value < swapFee) {\n            revert notEnoughGas();\n        }\n        yield += swapFee;\n        uint256 unrequiredFee = msg.value - swapFee; // In case the msg.sender sent more value than it is required\n        //CALCULATION\n        uint256 n = getAssetOne();\n        uint256 assetTwo = getAssetTwo() + _amount;\n        uint256 assetOne = liquidity / assetTwo;\n        uint256 result = n - assetOne;\n        //GETTING THE ASSET FROM CALLER TO THE LIQUIDITY POOL AND SENDING THE OPPOSITE ASSET TO THE CALLER FROM LIQUIDITY POOL\n        IERC20(assetTwoAddress).transferFrom(msg.sender, address(this), _amount);\n        IERC20(assetOneAddress).transfer(msg.sender, result);\n        payable(msg.sender).transfer(unrequiredFee); // Sending back the unrequired fee\n        //EVENTS\n        emit priceChanged(assetOneAddress, assetOnePrice());\n        emit priceChanged(assetTwoAddress, assetTwoPrice());\n    }\n\n    /**\n     * @dev Function to get the current balance of a given asset held by the contract.\n     * @param _address The address of the asset.\n     * @return The current balance of the asset.\n     */\n    function getAssetBalace(address _address) public view returns (uint256) {\n        return IERC20(_address).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the current price of the first asset in terms of the second asset.\n     * @return The current price of the first asset * 10**18.\n     */\n    function assetOnePrice() public view returns (uint256) {\n        return (getAssetTwo() * 1 ether) / getAssetOne();\n    }\n\n    /**\n     * @dev Function to get the current price of the second asset in terms of the first asset.\n     * @return The current price of the second asset * 10**18.\n     */\n    function assetTwoPrice() public view returns (uint256) {\n        return (getAssetOne() * 1 ether) / getAssetTwo();\n    }\n\n    /**\n     * @dev Function to get the amount of the first asset held by the contract.\n     * @return The current balance of the first asset.\n     */\n    function getAssetOne() public view returns (uint256) {\n        return IERC20(assetOneAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the amount of the second asset held by the contract.\n     * @return The current balance of the second asset.\n     */\n    function getAssetTwo() public view returns (uint256) {\n        return IERC20(assetTwoAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the quantity of LP tokens owned by a specific address.\n     * @param _address The address of the LP token holder.\n     * @return The quantity of LP tokens owned by the address.\n     */\n    function getLpTokenQuantity(address _address) public view returns (uint256) {\n        if (msg.sender != owner && _address == msg.sender) {\n            revert addressNotCorrect();\n        }\n        return lpTokenQuantity[_address];\n    }\n\n    /**\n     * @dev Function to get the total liquidity in the pool.\n     * @return The total liquidity in the pool.\n     */\n    function getLiquidity() public view returns (uint256) {\n        return liquidity;\n    }\n\n    /**\n     * @dev Function to get the current swap fee percentage.\n     * @return The current swap fee percentage.\n     */\n    function getSwapFee() public view returns (uint256) {\n        return swapFee;\n    }\n\n    /**\n     * @dev Function to get the current ETH balance of the contract.\n     * @return The current ETH balance of the contract.\n     */\n    function addressBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Function to get the quantity of the second asset that would be returned for a given amount of the first asset.\n     * @param sellingAsset The address of the asset being sold.\n     * @param _amount The amount of the first asset being sold.\n     * @return The quantity of the second asset that would be returned\n     */\n    function getSwapQuantity(address sellingAsset, uint256 _amount) public view returns (uint256) {\n        if (sellingAsset == assetOneAddress) {\n            uint256 newAssetOne = getAssetOne() + _amount;\n            uint256 newAssetTwo = liquidity / newAssetOne;\n            return getAssetTwo() - newAssetTwo;\n        } else if (sellingAsset == assetTwoAddress) {\n            uint256 newAssetTwo = getAssetTwo() + _amount;\n            uint256 newAssetOne = liquidity / newAssetTwo;\n            return getAssetOne() - newAssetOne;\n        } else {\n            revert assetNotCorrect();\n        }\n    }\n\n    /**\n     * @dev Function to get the second part of the liquidity token pair needed for providing liquidity.\n     * @param _asset The address of the asset.\n     * @param _amount The amount of the asset.\n     * @return The quantity of the second asset needed for providing liquidity.\n     */\n    function amountOfOppositeTokenNeeded(\n        address _asset,\n        uint256 _amount\n    ) public view returns (uint256) {\n        uint256 ratio;\n        if (_asset == assetOneAddress) {\n            ratio = (getAssetTwo() * 1 ether) / getAssetOne();\n        } else {\n            ratio = (getAssetOne() * 1 ether) / getAssetTwo();\n        }\n        uint256 amountNeeded = (_amount * ratio) / 1 ether;\n        return amountNeeded;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Yield Farming and Time Locks\n\n    // Daily yield tracking\n    mapping(address => uint256) public yieldTaken;\n\n    /**\n     * @dev Function to get the current yield amount available in the pool.\n     * @return The current yield amount.\n     */\n    function yieldAmount() public view returns (uint256) {\n        return yield;\n    }\n\n    /**\n     * @dev Function to allow users to claim their yield. Can be called once a day.\n     */\n    function getYield() public {\n        if (isTime() == false) {\n            revert notEnoughTimePassed();\n        }\n        lastYieldFarmedTime[msg.sender] = block.timestamp; // Reentrancy guard\n        uint256 yieldSoFar = yieldTaken[msg.sender];\n        uint256 userLiquidity = (lpTokenQuantity[msg.sender] * 100) / liquidity;\n        uint256 availableYield = ((yield - ((yieldSoFar * 100) / userLiquidity)) * userLiquidity) /\n            100;\n        if (availableYield > address(this).balance) {\n            revert notEnoughTokens(); // IN CASE THERE IS A LOT OF PEOPLE GETTING YIELD AT ONCE AND RATIOS GET CHANGED TOO MUCH\n        }\n        yieldTaken[msg.sender] += availableYield;\n        payable(msg.sender).transfer(availableYield);\n\n        // EMIT EVENT\n        emit yieldFarmed(msg.sender, availableYield);\n    }\n\n    // Timestamp mapping for yield farming\n    mapping(address => uint256) public lastYieldFarmedTime;\n    mapping(address => uint256) public initialLiquidityProvidedTime;\n\n    /**\n     * @dev Function to check if enough time has passed for the user to claim yield.\n     * @return Whether enough time has passed or not.\n     */\n    function isTime() public view returns (bool) {\n        lastYieldFarmedTime[msg.sender];\n        uint256 currentStamp = block.timestamp;\n        if ((lastYieldFarmedTime[msg.sender] + 1 days) < currentStamp) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Function to check if enough time has passed since the initial liquidity was provided.\n     * @return Whether enough time has passed or not.\n     */\n    function isTimeInitialLiquidity() public view returns (bool) {\n        if (block.timestamp > (initialLiquidityProvidedTime[msg.sender] + 365 days)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Fallback function if address calls unexisting function, but contains msg.data\n     * @notice The transaction gets reverted since the contract doesn't have the infrastructure to process it\n     */\n    fallback() external payable {\n        revert needToCallExistingFunction();\n    }\n\n    /**\n     * @dev Receive function if address calls unexisting function, without msg.data\n     * @notice The transaction gets reverted since the contract doesn't have the infrastructure to process it\n     */\n    receive() external payable {\n        revert needToCallExistingFunction();\n    }\n}\n"
    },
    "contracts/PoolTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./LiquidityPool.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// Errors\nerror PoolTracker_noTokensDetected();\nerror PoolTracker_pairAlreadyExists();\nerror PoolTracker_addressNotAllowed();\n\n// To do:\n// Timer: if the owner doesnt deploy initial liquidity in one day the\n// liquidity pool gets untracked, is not part of platform anymore\ncontract PoolTracker {\n    // PoolTracker Owner\n    address owner;\n\n    // Constructor, sets the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // Tracker for created pools, will add to database\n    event poolCreated(LiquidityPool pool, address assetOne, address assetTwo);\n\n    // Mapping of pool Pairs, to store existing ones\n    mapping(address => address[]) public poolPairs;\n\n    // Mapping a pool to the contracts, in case we wont store it in the database\n    mapping(address => mapping(address => LiquidityPool)) public pairToPool;\n\n    // All the available tokens\n    address[] public tokens;\n\n    // All pools\n    address[] public pools;\n\n    // Pool creator, approve enough for two transferfroms(one to contract(by msg sender) and one from contract(by contract))\n    function createPool(\n        address _assetOneAddress,\n        address _assetTwoAddress,\n        uint256 amountOne,\n        uint256 amountTwo\n    ) external noReentrancy {\n        if (exists(_assetOneAddress, _assetTwoAddress)) // To prevent duplicate pools\n        {\n            revert PoolTracker_pairAlreadyExists();\n        }\n        // Transfer of tokens\n        IERC20(_assetOneAddress).transferFrom(msg.sender, address(this), amountOne);\n        IERC20(_assetTwoAddress).transferFrom(msg.sender, address(this), amountTwo);\n        // Creation of pool\n        LiquidityPool poolAddress = new LiquidityPool(_assetOneAddress, _assetTwoAddress);\n        // Approve\n        IERC20(_assetOneAddress).approve(address(poolAddress), amountOne);\n        IERC20(_assetTwoAddress).approve(address(poolAddress), amountTwo);\n        // Add initial liquidity\n        poolAddress.addInitialLiquidity(amountOne, amountTwo);\n        // Update mappings\n        poolPairs[_assetOneAddress].push(_assetTwoAddress);\n        poolPairs[_assetTwoAddress].push(_assetOneAddress);\n        pairToPool[_assetOneAddress][_assetTwoAddress] = poolAddress;\n        pairToPool[_assetTwoAddress][_assetOneAddress] = poolAddress;\n\n        // tokens.push()\n        if (tokenExists(_assetOneAddress) == false) {\n            tokens.push(_assetOneAddress);\n        }\n        if (tokenExists(_assetTwoAddress) == false) {\n            tokens.push(_assetTwoAddress);\n        }\n        pools.push(address(poolAddress));\n        // Emit the event\n        emit poolCreated(poolAddress, _assetOneAddress, _assetTwoAddress);\n    }\n\n    // To check if a pool pair exists\n    function exists(address token1, address token2) public view returns (bool) {\n        bool exist;\n        for (uint256 i; i < poolPairs[token1].length; i++) {\n            if (poolPairs[token1][i] == token2) {\n                exist = true;\n            }\n        }\n        return exist;\n    }\n\n    function tokenExists(address tokenAddress) public view returns (bool) {\n        bool exist;\n        for (uint256 i; i < tokens.length; i++) {\n            if (tokenAddress == tokens[i]) {\n                exist = true;\n                break;\n            }\n        }\n        return exist;\n    }\n\n    // Routing token\n    struct routingAddress {\n        address tokenAddress;\n        address priceFeed;\n    }\n\n    // Array of routing Tokens\n    routingAddress[] public routingAddresses;\n\n    // Add routing address\n    function addRoutingAddress(address tokenAddress, address priceFeed) public {\n        if (msg.sender != owner) {\n            revert PoolTracker_addressNotAllowed();\n        }\n        if (routingAddresses.length == 0) {\n            routingAddresses.push(routingAddress(tokenAddress, priceFeed));\n        } else {\n            for (uint256 i = 0; i < routingAddresses.length; i++) {\n                if (routingAddresses[i].tokenAddress == tokenAddress) {\n                    routingAddresses[i] = routingAddress(tokenAddress, priceFeed); // In case we want to update priceFeed address of existing token\n                    break;\n                } else if (i == routingAddresses.length - 1) {\n                    // If it is the last one and isnt the same\n                    routingAddresses.push(routingAddress(tokenAddress, priceFeed));\n                }\n            }\n        }\n    }\n\n    function tokenToRoute(address address1, address address2) public view returns (address) {\n        address[] memory token1pairs = poolPairs[address1];\n        address[] memory token2pairs = poolPairs[address2];\n\n        address routingToken;\n        int routingTokenLiquidity;\n\n        for (uint256 i; i < token1pairs.length; i++) {\n            for (uint256 a; a < token2pairs.length; a++) {\n                if (token1pairs[i] == token2pairs[a]) {\n                    for (uint256 b; b < routingAddresses.length; b++) {\n                        if (routingAddresses[b].tokenAddress == token1pairs[i]) {\n                            (, int answer, , , ) = AggregatorV3Interface(\n                                routingAddresses[b].priceFeed\n                            ).latestRoundData();\n                            int liquidity;\n                            LiquidityPool pool1 = pairToPool[address1][\n                                routingAddresses[b].tokenAddress\n                            ];\n                            LiquidityPool pool2 = pairToPool[address2][\n                                routingAddresses[b].tokenAddress\n                            ];\n                            uint256 balance1 = IERC20(routingAddresses[b].tokenAddress).balanceOf(\n                                address(pool1)\n                            );\n                            uint256 balance2 = IERC20(routingAddresses[b].tokenAddress).balanceOf(\n                                address(pool2)\n                            );\n                            liquidity = (int(balance1) + int(balance2)) * answer;\n                            if (liquidity > routingTokenLiquidity) {\n                                // Best choice so far if the liquidty is bigger than previous best token\n                                routingToken = routingAddresses[b].tokenAddress;\n                                routingTokenLiquidity = liquidity;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return routingToken;\n    }\n\n    /**\n     * @dev Returns all array of all tradable tokens on the platform\n     *\n     * @return array Returns tokens array.\n     */\n    function tokenList() external view returns (address[] memory) {\n        return tokens;\n    }\n\n    /**\n     * @dev Retrieve pool addresses\n     *\n     * @return array Returns pools array\n     */\n    function getPools() public view returns (address[] memory) {\n        return pools;\n    }\n}\n"
    },
    "contracts/SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n// Importing required contracts and interfaces\nimport \"./PoolTracker.sol\";\nimport \"./LiquidityPool.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\n// Importing CCIP\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {OwnerIsCreator} from \"@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol\";\n\n// Error declaration for unswappable token pairs\nerror SwapRouter_tokensCantBeSwapped();\nerror SwapRouter_needToCallExistingFunction();\nerror SwapRouter_NotEnoughBalance();\nerror SwapRouter_ChainNotAvailable();\n\n/**\n * @title SwapRouter\n * @dev Facilitates token swaps utilizing defined liquidity pools, offering direct swaps and routed swaps through an intermediary.\n * Leverages the PoolTracker contract to access liquidity pool information and perform asset exchanges.\n */\ncontract SwapRouter is CCIPReceiver, OwnerIsCreator {\n    // Emitted after a successful token swap\n    event swap(\n        address userAddress,\n        address address1,\n        address address2,\n        uint256 address1Amount,\n        uint256 address2Amount\n    );\n\n    // Reference to the PoolTracker contract for pool operations\n    PoolTracker poolTracker;\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /**\n     * @param tracker Address of the PoolTracker contract instance.\n     */\n    constructor(address tracker, address _router) CCIPReceiver(_router) {\n        poolTracker = PoolTracker(tracker);\n    }\n\n    /**\n     * @notice Swaps `inputAmount` of `address1` tokens for `address2` tokens.\n     * @dev This function supports direct swaps between tokens in a single pool or routed swaps through an intermediary token.\n     * Uses PoolTracker to determine the best swap path and perform the exchange.\n     * @param address1 The token being sold by the user.\n     * @param address2 The token being purchased by the user.\n     * @param inputAmount The amount of `address1` tokens to swap.\n     */\n    function swapAsset(\n        address address1,\n        address address2,\n        uint256 inputAmount\n    ) public payable noReentrancy {\n        if (poolTracker.exists(address1, address2)) {\n            // Direct swap scenario\n            LiquidityPool pool = poolTracker.pairToPool(address1, address2);\n            uint256 startingBalanceAddress2 = IERC20(address2).balanceOf(address(this));\n            if (pool.assetOneAddress() == address1) {\n                IERC20(address1).transferFrom(msg.sender, address(this), inputAmount);\n                IERC20(address1).approve(address(pool), inputAmount);\n                pool.sellAssetOne{value: pool.swapFee()}(inputAmount);\n            } else {\n                IERC20(address1).transferFrom(msg.sender, address(this), inputAmount);\n                IERC20(address1).approve(address(pool), inputAmount);\n                pool.sellAssetTwo{value: pool.swapFee()}(inputAmount);\n            }\n            uint256 amountOutput = IERC20(address2).balanceOf(address(this)) -\n                startingBalanceAddress2;\n            IERC20(address2).transfer(msg.sender, amountOutput);\n            // Unrequired fee\n            uint256 unrequiredFee = msg.value - pool.swapFee(); // In case the msg.sender sent more value than it is required\n            (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n            require(sent, \"Failed to send Ether\");\n        } else if (poolTracker.tokenToRoute(address1, address2) != address(0)) {\n            // Routed swap scenario\n            address routingToken = poolTracker.tokenToRoute(address1, address2);\n            LiquidityPool pool1 = poolTracker.pairToPool(address1, routingToken);\n            LiquidityPool pool2 = poolTracker.pairToPool(address2, routingToken);\n            uint256 startingBalance = IERC20(routingToken).balanceOf(address(this));\n            uint256 startingBalance2 = IERC20(address2).balanceOf(address(this));\n            //SWAP 1, input token into routing  token\n            if (pool1.assetOneAddress() == address1) {\n                IERC20(address1).transferFrom(msg.sender, address(this), inputAmount);\n                IERC20(address1).approve(address(pool1), inputAmount);\n                pool1.sellAssetOne{value: pool1.swapFee()}(inputAmount);\n            } else {\n                IERC20(address1).transferFrom(msg.sender, address(this), inputAmount);\n                IERC20(address1).approve(address(pool1), inputAmount);\n                pool1.sellAssetTwo{value: pool1.swapFee()}(inputAmount);\n            }\n            //SWAP 2, routing token into output token\n            uint256 routingTokenInput = IERC20(routingToken).balanceOf(address(this)) -\n                startingBalance;\n            if (pool2.assetOneAddress() == address1) {\n                IERC20(routingToken).approve(address(pool2), routingTokenInput);\n                pool2.sellAssetOne{value: pool2.swapFee()}(routingTokenInput);\n            } else {\n                IERC20(routingToken).approve(address(pool2), routingTokenInput);\n                pool2.sellAssetTwo{value: pool2.swapFee()}(routingTokenInput);\n            }\n            uint256 address2Output = IERC20(address2).balanceOf(address(this)) - startingBalance2;\n            IERC20(address2).transfer(msg.sender, address2Output);\n            // Unrequired fee\n            uint256 unrequiredFee = msg.value - pool1.swapFee() - pool2.swapFee(); // In case the msg.sender sent more value than it is required\n            (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n            require(sent, \"Failed to send Ether\");\n        } else {\n            // Assets cant be swapped directly nor routed\n            revert SwapRouter_tokensCantBeSwapped();\n        }\n    }\n\n    /**\n     * @notice Estimates the output amount for a swap from `address1` to `address2` given an `inputAmount` of `address1`.\n     * @dev Considers direct swaps and routed swaps through an intermediary token, utilizing PoolTracker for calculations.\n     * @param address1 The token being sold.\n     * @param address2 The token being bought.\n     * @param inputAmount The amount of `address1` tokens to swap.\n     * @return output The estimated amount of `address2` tokens to be received.\n     */\n    function getSwapAmount(\n        address address1,\n        address address2,\n        uint256 inputAmount\n    ) public view returns (uint256) {\n        uint256 output;\n        if (poolTracker.exists(address1, address2)) {\n            LiquidityPool pool = poolTracker.pairToPool(address1, address2);\n            output = pool.getSwapQuantity(address1, inputAmount);\n        } else if (poolTracker.tokenToRoute(address1, address2) != address(0)) {\n            address routingToken = poolTracker.tokenToRoute(address1, address2);\n            LiquidityPool pool1 = poolTracker.pairToPool(address1, routingToken);\n            LiquidityPool pool2 = poolTracker.pairToPool(address2, routingToken);\n            uint256 routingOutput = pool1.getSwapQuantity(address1, inputAmount);\n            output = pool2.getSwapQuantity(routingToken, routingOutput);\n        } else {\n            // Assets cant be swapped directly nor routed\n            revert SwapRouter_tokensCantBeSwapped();\n        }\n        return output;\n    }\n\n    /**\n     * @dev Fallback function if address calls unexisting function, but contains msg.data\n     */\n    fallback() external payable {}\n\n    /**\n     * @dev Receive function if address calls unexisting function, without msg.data\n     */\n    receive() external payable {}\n\n    //CCIP\n\n    //Mapping of our swapRouter contracts\n    mapping(uint64 => address) public swapContracts;\n\n    //Adding swap contracts\n    function addSwapContracts(uint64 _chainId, address _swapContract) public onlyOwner {\n        swapContracts[_chainId] = _swapContract;\n    }\n\n    //This is the CCIP bridgin token\n    address bridgingToken; // This is the chainlink bridging token\n\n    //Function to add bridging token\n    function addBridgingToken(address tokenAddress) public onlyOwner {\n        bridgingToken = tokenAddress;\n    }\n\n    //Sends the swap request to Swap Router on a different chain\n    //It would be good to check if we can the list of tradable tokens on the other chain, however frontend could implement list to spend less gas\n    //If fee not high enough it wont perform the swap, use more fee in that case(the contract returns unrequired fee)\n    function sendSwapRequest(\n        uint64 _destinationChain, //Destination Chain\n        address address1, //Input swap token\n        address address2, //Output swap token(must be address of an asset on the other chain)\n        uint256 inputAmount //Input token Amount\n    ) public payable returns (bytes32 messageId) {\n        //Checking the mappings with our dexes to see if available\n        address _receiver = swapContracts[_destinationChain];\n        if (_receiver == address(0)) {\n            revert SwapRouter_ChainNotAvailable();\n        }\n        //PERFORM SWAP\n        if (poolTracker.exists(address1, address2)) {\n            // Direct swap scenario\n            LiquidityPool pool = poolTracker.pairToPool(address1, address2);\n            uint256 startingBalanceAddress2 = IERC20(address2).balanceOf(address(this));\n            if (pool.assetOneAddress() == address1) {\n                IERC20(address1).transferFrom(msg.sender, address(this), inputAmount);\n                IERC20(address1).approve(address(pool), inputAmount);\n                pool.sellAssetOne{value: pool.swapFee()}(inputAmount);\n            } else {\n                IERC20(address1).transferFrom(msg.sender, address(this), inputAmount);\n                IERC20(address1).approve(address(pool), inputAmount);\n                pool.sellAssetTwo{value: pool.swapFee()}(inputAmount);\n            }\n            uint256 amountOutput = IERC20(address2).balanceOf(address(this)) -\n                startingBalanceAddress2;\n            IERC20(address2).transfer(msg.sender, amountOutput);\n            // Unrequired fee\n            uint256 unrequiredFee = msg.value - pool.swapFee(); // In case the msg.sender sent more value than it is required\n            (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n            require(sent, \"Failed to send Ether\");\n        } else {\n            revert SwapRouter_tokensCantBeSwapped();\n        }\n        uint256 _amountBridginToken; // get from the swap(routing token output)\n        //SEND MESSAGE AND TOKENS\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _receiver,\n            address2,\n            _amountBridginToken,\n            bridgingToken,\n            msg.sender\n        );\n        IRouterClient router = IRouterClient(this.getRouter());\n\n        uint256 fees = router.getFee(_destinationChain, evm2AnyMessage);\n\n        if (fees > address(this).balance) {\n            revert SwapRouter_NotEnoughBalance();\n        }\n\n        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token\n        IERC20(bridgingToken).approve(address(router), _amountBridginToken);\n\n        // Send the message through the router and store the returned message ID\n        messageId = router.ccipSend{value: fees}(_destinationChain, evm2AnyMessage);\n        return messageId;\n    }\n\n    /// Handle a received message\n    function _ccipReceive(\n        Client.Any2EVMMessage memory any2EvmMessage // The message the SwapRouter receives\n    ) internal override {\n        // Save message\n        s_lastReceivedMessageId = any2EvmMessage.messageId;\n        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;\n        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;\n        // abi-decoding of the sent data\n        (address outputToken, uint256 amount, address user) = abi.decode(\n            any2EvmMessage.data,\n            (address, uint256, address)\n        );\n        // If user doesnt have the balance to pay for fees, we give him back tokens\n        LiquidityPool pool = poolTracker.pairToPool(bridgingToken, outputToken);\n        if (feeBalance[user] < pool.getSwapFee() || address(pool) == address(0)) {\n            IERC20(bridgingToken).transfer(user, amount);\n            revert SwapRouter_tokensCantBeSwapped();\n        }\n        // SWAP LOGIC\n        // Direct swap scenario, cant do indirect(thus we need to provide enough pools in our dex with this token)\n        uint256 startingBalanceAddress2 = IERC20(outputToken).balanceOf(address(this));\n        if (pool.assetOneAddress() == bridgingToken) {\n            IERC20(bridgingToken).approve(address(pool), amount);\n            pool.sellAssetOne{value: pool.swapFee()}(amount);\n        } else {\n            IERC20(bridgingToken).approve(address(pool), amount);\n            pool.sellAssetTwo{value: pool.swapFee()}(amount);\n        }\n        uint256 amountOutput = IERC20(outputToken).balanceOf(address(this)) -\n            startingBalanceAddress2;\n        IERC20(outputToken).transfer(user, amountOutput);\n        // Deduct the fee\n        feeBalance[user] -= pool.swapFee();\n    }\n\n    function _buildCCIPMessage(\n        address _receiverContract, // The SwapRouter contract where the tokens will get delivered\n        address outputToken, // Receiving message\n        uint256 routingInputAmount, // Receiving message and transfer\n        address _token, // Bridging token(provided by Chainlink)\n        address _receiverUser // User that will receive tokens\n    ) private pure returns (Client.EVM2AnyMessage memory) {\n        // Set the token amounts\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount({token: _token, amount: routingInputAmount});\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\n        return\n            Client.EVM2AnyMessage({\n                receiver: abi.encode(_receiverContract), // ABI-encoded receiver address\n                data: abi.encodePacked(outputToken, routingInputAmount, _receiverUser), // ABI-encoded parameters\n                tokenAmounts: tokenAmounts, // The amount and type of token being transferred\n                extraArgs: Client._argsToBytes(\n                    // Additional arguments, setting gas limit\n                    Client.EVMExtraArgsV1({gasLimit: 200_000})\n                ),\n                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\n                feeToken: address(0)\n            });\n    }\n\n    // Message saved\n    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.\n    address private s_lastReceivedTokenAddress; // Store the last received token address.\n    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.\n\n    /**\n     * @notice Returns the details of the last CCIP received message.\n     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.\n     * @return messageId The ID of the last received CCIP message.\n     * @return tokenAddress The address of the token in the last CCIP received message.\n     * @return tokenAmount The amount of the token in the last CCIP received message.\n     */\n    function getLastReceivedMessageDetails()\n        public\n        view\n        returns (bytes32 messageId, address tokenAddress, uint256 tokenAmount)\n    {\n        return (s_lastReceivedMessageId, s_lastReceivedTokenAddress, s_lastReceivedTokenAmount);\n    }\n\n    // Mapping to see how much fee the user has deposited to the contract\n    mapping(address => uint256) public feeBalance;\n\n    // Function for user to add fees to his fees balance(used for swaping CCIP)\n    function addFeeBalance() public payable {\n        feeBalance[msg.sender] += msg.value;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}